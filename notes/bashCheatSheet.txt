!!      run last command
!blah   run the most recent command that starts with ‘blah’ (e.g. !ls)
!blah:p print out the command that !blah would run (also adds it as the latest command in the command history)
!$      the last word of the previous command (same as Alt + .)
!$:p    print out the word that !$ would substitute
!*      the previous command except for the last word (e.g. if you type ‘find some_file.txt /‘, then !* would give you ‘find some_file.txt‘)
!*:p    print out what !* would substitute

-a file    True if file exists.
-b file    True if file exists and is a block special file.
-c file    True if file exists and is a character special file.
-d file    True if file exists and is a directory.
-e file    True if file exists.
-f file    True if file exists and is a regular file.
-g file    True if file exists and is set-group-id.
-h file    True if file exists and is a symbolic link.
-k file    True if file exists and its ``sticky'' bit is set.
-p file    True if file exists and is a named pipe (FIFO).
-r file    True if file exists and is readable.
-s file    True if file exists and has a size greater than zero.
-t fd      True if file descriptor fd is open and refers to a terminal.
-u file    True if file exists and its set-user-id bit is set.
-w file    True if file exists and is writable.
-x file    True if file exists and is executable.

integer comparison:
-eq  |  Is equal to:                                                if [ "$a" -eq "$b" ]
-ne  |  Is not equal to:                                            if [ "$a" -ne "$b" ]
-gt  |  Is greater than:                                            if [ "$a" -gt "$b" ]
-ge  |  Is greater than or equal to:                                if [ "$a" -ge "$b" ]
-lt  |  Is less than:                                               if [ "$a" -lt "$b" ]
-le  |  Is less than or equal to:                                   if [ "$a" -le "$b" ]
<    |  Is less than (within double parentheses):                   (("$a" < "$b"))
<=   |  Is less than or equal to (within double parentheses):       (("$a" <= "$b"))
>    |  Is greater than (within double parentheses):                (("$a" > "$b"))
>=   |  Is greater than or equal to (within double parentheses):    (("$a" >= "$b"))

string comparison:
=
    is equal to: if [ "$a" = "$b" ]
    Caution
    Note the whitespace framing the =.
    if [ "$a"="$b" ] is not equivalent to the above.
==
    is equal to
    if [ "$a" == "$b" ]
    This is a synonym for =.
    Note
    The == comparison operator behaves differently within a double-brackets test than within single brackets.
    [[ $a == z* ]]   # True if $a starts with an "z" (pattern matching).
    [[ $a == "z*" ]] # True if $a is equal to z* (literal matching).
    [ $a == z* ]     # File globbing and word splitting take place.
    [ "$a" == "z*" ] # True if $a is equal to z* (literal matching).
    # Thanks, Stéphane Chazelas
!=
    is not equal to
    if [ "$a" != "$b" ]
    This operator uses pattern matching within a [[ ... ]] construct.
<
    is less than, in ASCII alphabetical order
    if [[ "$a" < "$b" ]]
    if [ "$a" \< "$b" ]
    Note that the "<" needs to be escaped within a [ ] construct.
>
    is greater than, in ASCII alphabetical order
    if [[ "$a" > "$b" ]]
    if [ "$a" \> "$b" ]
    Note that the ">" needs to be escaped within a [ ] construct.
    See Example 27-11 for an application of this comparison operator.
-z
    string is null, that is, has zero length
     String=''   # Zero-length ("null") string variable.
    if [ -z "$String" ]
    then
      echo "\$String is null."
    else
      echo "\$String is NOT null."
    fi     # $String is null.
-n
    string is not null.
    Caution
    The -n test requires that the string be quoted within the test brackets. Using an unquoted string with ! -z, or even just the unquoted string alone within test brackets (see Example 7-6) normally works, however, this is an unsafe practice. Always quote a tested string. [1]